# AI-云寻：基于 MCP 的大模型数据分析工具链

## 摘要

AI-云寻是一个基于 MCP 协议的项目，目标是让大模型更容易调用数据分析工具。项目用 MCP Java SDK 写 MCP server，用 MCP TypeScript SDK 写 MCP client，再用 TS 代码把“模型 -> 工具 -> 再次模型”的调用链路串起来。模型使用智谱 `glm-4.7-flash`，通过 function call 触发工具调用。当前只支持 SSE 通信，MCP server 可部署在服务器上，不支持 HTTP 协议和 stdio 协议。当前实现的工具包括 Neo4j 操作工具和 ECharts 关系图绘制工具。本文基于已有代码和文档，说明需求、设计、实现与测试结果，并给出后续可扩展方向。

关键词：MCP；function call；SSE；Neo4j；ECharts；智谱

## 1 背景与目标

### 1.1 背景

大模型能理解自然语言，但要完成数据分析任务，往往需要外部工具，比如数据库查询、图表生成等。MCP 协议提供了统一的工具调用规范，让模型更容易接入外部能力。本项目基于 MCP，把数据库查询和图表绘制变成可调用工具，再让模型在对话中调用这些工具完成分析。

### 1.2 目标

- 建一个可用的 MCP 工具链路，支持模型调用工具并拿到结果。
- 通过 Neo4j 工具完成图数据库查询和写入。
- 通过 ECharts 工具生成关系图 option，并在前端可视化。
- 提供一个简单可用的前端控制台，能看到模型回复、工具调用过程和结果。

## 2 需求分析

### 2.1 功能需求

- 模型对话：支持用户输入自然语言，模型返回文字。
- 工具调用：模型触发 MCP 工具调用，并把结果回填到对话。
- Neo4j 工具：支持 schema 查询、读查询、写查询。
- ECharts 工具：支持生成 graph 图的 option。
- 前端显示：展示对话内容、工具调用过程、图表结果。

### 2.2 非功能需求

- 走 SSE 流式通信，保证对话和工具结果的实时性。
- MCP server 可以独立部署，client 通过 URL 连接。
- 结构清晰，方便后续扩展新的 MCP 工具。

## 3 总体设计

### 3.1 架构

系统分为三块：

1) MCP Server（Java/Spring Boot）：提供工具能力  
2) MCP Client（TS/Next.js）：负责模型调用和工具调用  
3) 第三方模型 API（智谱）：提供对话和 function call

数据流（一次对话的基本路径）：

1) 用户输入 -> `/api/chat`  
2) MCP client 请求智谱模型  
3) 模型返回 tool_calls -> MCP client 调 MCP server  
4) 工具返回结果 -> 再请求模型  
5) 结果通过 SSE 推给前端

### 3.2 模块划分

项目的模块划分直接体现在目录结构里，三个主模块如下：

- `mcp/server/neo4j`：Neo4j MCP server  
  - `db`：Neo4j 连接管理（驱动初始化、连通性校验）  
  - `service`：Cypher 读写与去重逻辑  
  - `tool`：MCP 工具入口（schema/读/写）  
  - `resources`：SSE 协议与 Neo4j 连接配置
- `mcp/server/echart`：ECharts MCP server  
  - `module`：ECharts graph option 的数据结构  
  - `tool`：MCP 工具入口（生成 graph option）  
  - `resources`：SSE 协议配置
- `mcp/client`：客户端项目（一个工程里包含 MCP client 和界面）  
  - `domain`：领域服务，负责“模型 -> 工具 -> 模型”的串行流程  
  - `infra/mcp`：MCP TypeScript SDK 封装与多 server 管理  
  - `infra/zhipu`：智谱 API 调用  
  - `app/api`：SSE 接口，把模型输出和工具结果推送给前端  
  - `ui`：界面组件（消息卡片、工具卡片、图表渲染）  
  - `app/page.tsx`：页面入口  

说明：`mcp/client` 里把 MCP 客户端能力和界面放在同一个项目中，但代码层面是分开的，分别在 `infra/mcp` 和 `ui` 目录里。

### 3.3 协议与通信

- MCP 协议用于定义工具、参数和调用方式 [1]
- 使用 SSE 作为 MCP server 与 client 的通信方式
- 项目当前不支持 HTTP 协议和 stdio 协议

## 4 详细设计与实现

### 4.1 MCP Client（前端）

位置：`mcp/client`

主要模块：

- `src/domain/llm/LLMService.ts`  
  调用智谱接口，解析流式返回和 tool_calls，并把事件分发给上层。
- `src/infra/mcp/client.ts`  
  封装 MCP TypeScript SDK，使用 `SSEClientTransport` 连接 MCP server。
- `src/infra/mcp/manager.ts`  
  管理多个 MCP server，拉取工具列表并统一调用。工具名统一加前缀，例如 `neo4j__read-neo4j-cypher`。
- `src/domain/chat/ServerChatService.ts`  
  实现“模型 -> 工具 -> 再次模型”的串行流程。
- `src/app/api/chat/route.ts`  
  SSE 接口，向前端持续推送文本、工具调用和结果事件。

界面部分：

- `src/ui/components`  
  用户消息、助手消息、工具卡片、ECharts 图表渲染。
- `ToolCard` 如果工具名以 `echart` 开头，会把结果当作 ECharts option 渲染。

### 4.2 Neo4j MCP Server

位置：`mcp/server/neo4j`

主要模块：

- `Neo4jApplication.java`  
  启动入口，禁用了 Spring Boot 默认的 Neo4j 自动配置。
- `Neo4jConnection.java`  
  使用 Neo4j Java Driver 管理连接，并在启动时校验连通性。
- `Neo4jService.java`  
  执行 Cypher 读写，并在读后执行去重逻辑。
- `Neo4jMCPTool.java`  
  MCP 工具入口，暴露三个工具：
  - `get-neo4j-schema`：调用 `apoc.meta.data()` 获取 schema [4]
  - `read-neo4j-cypher`：只允许读语句，读完后调用 `apoc.refactor.mergeNodes` 做去重 [5]
  - `write-neo4j-cypher`：执行写语句并返回统计结果

配置：

- `src/main/resources/application.yml`  
  - `server.port` 默认 8082  
  - `spring.ai.mcp.server.protocol` 为 `SSE`  
  - `neo4j.uri` / `neo4j.username` / `neo4j.password` / `neo4j.database`

### 4.3 ECharts MCP Server

位置：`mcp/server/echart`

主要模块：

- `EchartApplication.java`  
  启动入口。
- `module`  
  定义 ECharts Graph option 的结构：`GraphOption` / `GraphSeries` / `GraphNode` / `GraphEdge` / `GraphCategory` / `GraphTitle`。
- `GraphEChartMCPTool.java`  
  MCP 工具入口：`generate_graph_chart`，生成 Graph 图的 option。

配置：

- `src/main/resources/application.yml`  
  - `server.port` 默认 8083  
  - `spring.ai.mcp.server.protocol` 为 `SSE`

### 4.4 工具调用链路（实际代码流程）

1) 前端提交消息到 `/api/chat`  
2) `ServerChatService` 请求智谱模型  
3) 模型返回 `tool_calls`，`McpManager` 调用对应 MCP server  
4) 工具结果作为 `tool` 消息追加  
5) 继续请求模型，直到不再需要工具  
6) 所有事件通过 SSE 推给前端

## 5 关键技术

### 5.1 MCP 协议

MCP 定义了工具注册、参数描述、调用方式以及结果格式，降低了模型与工具之间的对接成本 [1]。本项目使用 MCP Java SDK 和 MCP TypeScript SDK 完成 server 和 client 的实现。

### 5.2 function call

模型通过 `tool_calls` 返回工具调用信息，client 解析后调用 MCP 工具，结果再回到模型中继续推理。这是本项目的核心链路。

### 5.3 SSE

SSE 用于在服务端向前端持续推送数据，适合流式输出。本项目在两个地方使用 SSE：

- MCP server 与 MCP client 的通信  
- `/api/chat` 与前端页面的通信

### 5.4 Neo4j 与 APOC

Neo4j 提供图数据库存储，APOC 插件提供 schema 查询和节点合并能力 [4][5]。本项目的 schema 获取和去重逻辑依赖 APOC。

### 5.5 ECharts 图表构建

ECharts 的 graph 图需要标准 option JSON。本项目在 MCP server 内部把输入数据转换成 ECharts option，再由前端渲染图表 [6]。

### 5.6 智谱开放平台

模型调用使用智谱开放平台接口 [7]，模型选择 `glm-4.7-flash`，并开启流式输出。

## 6 测试与结果

### 6.1 测试环境

- 操作系统：Windows
- 前端：Next.js
- MCP Server：Spring Boot
- 数据库：Neo4j

### 6.2 测试内容

- 模型对话是否能返回文本  
- tool_calls 是否能触发工具调用  
- Neo4j schema 查询和读写是否可用  
- ECharts option 是否能生成并渲染  
- SSE 是否稳定推送消息和工具结果

### 6.3 结果

以上功能在本地联调通过。当前版本主要完成了核心链路验证，未做权限、并发优化和大规模数据测试。

## 7 总结与展望

本项目完成了基于 MCP 的模型工具链路，实现了 Neo4j 查询和 ECharts 图表生成，并提供了可用的前端控制台。后续可扩展方向：

- 增加更多 MCP 工具（如统计分析、文件处理）
- 增加鉴权、调用配额与日志持久化
- 支持 HTTP 和 stdio 协议
- 增加更完整的自动化测试

## 参考文献

[1] Model Context Protocol 官方文档. https://modelcontextprotocol.io/docs  
[2] Spring AI 官方文档. https://docs.spring.io/spring-ai/reference/  
[3] Spring AI MCP 相关说明（Spring AI 社区扩展）. https://docs.spring.io/spring-ai/reference/api/mcp.html  
[4] Neo4j APOC 插件文档. https://neo4j.com/docs/apoc/current/  
[5] apoc.meta.data / apoc.refactor.mergeNodes.  
https://neo4j.com/docs/apoc/current/overview/apoc.meta/apoc.meta.data/  
https://neo4j.com/docs/apoc/current/overview/apoc.refactor/apoc.refactor.mergeNodes/  
[6] Apache ECharts 官方文档. https://echarts.apache.org/  
[7] 智谱开放平台文档. https://open.bigmodel.cn/dev/api
